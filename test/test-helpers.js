const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

/************************************
 *
 *  TEST FIXTURES
 *
 ************************************/
function makeUserRolesArray() {
  return [
    {
      id: 1,
      role_name: 'Educator',
    },
    {
      id: 2,
      role_name: 'Student',
    },
  ];
}

function makeRegisteredUsersArray() {
  return [
    //  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    {
      id: 1,
      user_name: 'mrssmith',
      full_name: 'Mrs. Smith',
      password: 'mrssmith',
      role_id_fk: '1',
    },
    {
      id: 2,
      user_name: 'buttreflyinthesky',
      full_name: 'LeVar Burton',
      password: 'buttreflyinthesky',
      role_id_fk: '1',
    },
    {
      id: 3,
      user_name: 'scienceguy',
      full_name: 'Bill Nye',
      password: 'scienceguy',
      role_id_fk: '1',
    },
    {
      id: 4,
      user_name: 'liljohn',
      full_name: 'John Doe',
      password: 'liljohn',
      role_id_fk: '2',
    },
    {
      id: 5,
      user_name: 'plainjane',
      full_name: 'Jane Doe',
      password: 'plainjane',
      role_id_fk: '2',
    },
  ];
}

function makeFlashcardsArray() {
  return [
    {
      id: 1,
      card_prompt: 'all',
      card_answer: 'https://hhvstaffing.com/audio/all.mp3',
    },
    {
      id: 2,
      card_prompt: 'am',
      card_answer: 'https://hhvstaffing.com/audio/am.mp3',
    },
    {
      id: 3,
      card_prompt: 'and',
      card_answer: 'https://hhvstaffing.com/audio/and.mp3',
    },
    {
      id: 4,
      card_prompt: 'big',
      card_answer: 'https://hhvstaffing.com/audio/big.mp3',
    },
    {
      id: 5,
      card_prompt: 'can',
      card_answer: 'https://hhvstaffing.com/audio/can.mp3',
    },
    {
      id: 6,
      card_prompt: 'go',
      card_answer: 'https://hhvstaffing.com/audio/go.mp3',
    },
    {
      id: 7,
      card_prompt: 'me',
      card_answer: 'https://hhvstaffing.com/audio/me.mp3',
    },
    {
      id: 8,
      card_prompt: 'my',
      card_answer: 'https://hhvstaffing.com/audio/my.mp3',
    },
    {
      id: 9,
      card_prompt: 'no',
      card_answer: 'https://hhvstaffing.com/audio/no.mp3',
    },
    {
      id: 10,
      card_prompt: 'so',
      card_answer: 'https://hhvstaffing.com/audio/so.mp3',
    },
    {
      id: 11,
      card_prompt: 'we',
      card_answer: 'https://hhvstaffing.com/audio/we.mp3',
    },
    {
      id: 12,
      card_prompt: 'yes',
      card_answer: 'https://hhvstaffing.com/audio/yes.mp3',
    },
    {
      id: 13,
      card_prompt: 'you',
      card_answer: 'https://hhvstaffing.com/audio/you.mp3',
    },
  ];
}

function makeDecksArray() {
  // todo
  // * is this used to load db and / or compare db results ?
  // * may need to restructure and add separate funcs for card/student link tables
  // ! By not including deck.id, no need to alter pk auto sequence to handle test adds
  return [
    {
      id: 1,
      deck_name: 'Long O (3 Cards)',
    },
    {
      id: 2,
      deck_name: 'All (13 Cards)',
    },
    {
      id: 3,
      deck_name: 'Starts with A (3 Cards)',
    },
  ];
}

function makeDeckCardLinkArray() {
  return [
    {
      deck_id_fk: 1,
      flashcard_id_fk: 6,
    },
    {
      deck_id_fk: 1,
      flashcard_id_fk: 9,
    },
    {
      deck_id_fk: 1,
      flashcard_id_fk: 10,
    },
    {
      deck_id_fk: 3,
      flashcard_id_fk: 1,
    },
    {
      deck_id_fk: 3,
      flashcard_id_fk: 2,
    },
    {
      deck_id_fk: 3,
      flashcard_id_fk: 3,
    },
  ];
}

function makeStudentDeckLinkArray() {
  return [
    {
      user_id_fk: 4,
      deck_id_fk: 1,
    },
    {
      user_id_fk: 5,
      deck_id_fk: 1,
    },
    {
      user_id_fk: 5,
      deck_id_fk: 2,
    },
    {
      user_id_fk: 5,
      deck_id_fk: 3,
    },
  ];
}

function makeTestFixtures() {
  const testRoles = makeUserRolesArray();
  const testUsers = makeRegisteredUsersArray();
  const testFlashcards = makeFlashcardsArray();
  const testDecks = makeDecksArray();
  const testDeckCardLinks = makeDeckCardLinkArray();
  const testStudentDeckLinks = makeStudentDeckLinkArray();
  return {
    testRoles,
    testUsers,
    testFlashcards,
    testDecks,
    testDeckCardLinks,
    testStudentDeckLinks,
  };
  //return { testUsers, testArticles, testComments };
}

/************************************
 *
 *  DB CLEANING/SEEDING
 *
 ************************************/
function cleanTables(db) {
  return db
    .raw(
      `TRUNCATE
      user_deck_link,
      deck_flashcard_link,
      deck,
      flashcard,
      registered_user,
      user_role
    RESTART IDENTITY CASCADE`
    )
    .then(() => {});
}

//function seedUsers(db, roles, users) {
function seedUsers(db, roles, users) {
  const hashedUsers = users.map((user) => ({
    ...user,
    password: bcrypt.hashSync(user.password, 1),
  }));

  return db
    .insert(roles)
    .into('user_role')
    .then(() => {
      db.insert(hashedUsers)
        .into('registered_user')
        .then(() => {}); //is .then needed for no return val or action?
    });
}

function seedCardTable(db, flashcards) {
  return db
    .insert(flashcards)
    .into('flashcard')
    .then(() => {});
}

function seedDecks(db, decks, cards, students) {
  return db.transaction(async (trx) => {
    await seedDeckTable(trx, decks);
    await seedDeckFlashcardLink(trx, cards);
    await seedUserDeckLink(trx, students);
  });
}

function seedDeckTable(db, decks) {
  return db.insert(decks).into('deck');
}

function seedDeckFlashcardLink(db, deckCardLinks) {
  return db.insert(deckCardLinks).into('deck_flashcard_link');
}

function seedUserDeckLink(db, userDeckLinks) {
  return db.insert(userDeckLinks).into('user_deck_link');
}

function initAllTables(db) {
  //seedUsers
  //seeedCards
  //seedDecks
}

// function makeExpectedArticle(users, article, comments = []) {
//   const author = users.find((user) => user.id === article.author_id);

//   const number_of_comments = comments.filter(
//     (comment) => comment.article_id === article.id
//   ).length;

//   return {
//     id: article.id,
//     style: article.style,
//     title: article.title,
//     content: article.content,
//     date_created: article.date_created.toISOString(),
//     number_of_comments,
//     author: {
//       id: author.id,
//       user_name: author.user_name,
//       full_name: author.full_name,
//       nickname: author.nickname,
//       date_created: author.date_created.toISOString(),
//       date_modified: author.date_modified || null,
//     },
//   };
// }

// function makeExpectedArticleComments(users, articleId, comments) {
//   const expectedComments = comments.filter(
//     (comment) => comment.article_id === articleId
//   );

//   return expectedComments.map((comment) => {
//     const commentUser = users.find((user) => user.id === comment.user_id);
//     return {
//       id: comment.id,
//       text: comment.text,
//       date_created: comment.date_created.toISOString(),
//       user: {
//         id: commentUser.id,
//         user_name: commentUser.user_name,
//         full_name: commentUser.full_name,
//         nickname: commentUser.nickname,
//         date_created: commentUser.date_created.toISOString(),
//         date_modified: commentUser.date_modified || null,
//       },
//     };
//   });
// }

// function makeMaliciousArticle(user) {
//   const maliciousArticle = {
//     id: 911,
//     style: 'How-to',
//     date_created: new Date(),
//     title: 'Naughty naughty very naughty <script>alert("xss");</script>',
//     author_id: user.id,
//     content: `Bad image <img src="https://url.to.file.which/does-not.exist" onerror="alert(document.cookie);">. But not <strong>all</strong> bad.`,
//   };
//   const expectedArticle = {
//     ...makeExpectedArticle([user], maliciousArticle),
//     title:
//       'Naughty naughty very naughty &lt;script&gt;alert("xss");&lt;/script&gt;',
//     content: `Bad image <img src="https://url.to.file.which/does-not.exist">. But not <strong>all</strong> bad.`,
//   };
//   return {
//     maliciousArticle,
//     expectedArticle,
//   };
// }

// function seedUsers(db, users) {
//   const preppedUsers = users.map((user) => ({
//     ...user,
//     password: bcrypt.hashSync(user.password, 12),
//   }));
//   return db
//     .into('registered_user')
//     .insert(preppedUsers)
//     .then(() =>
//       // update the auto sequence to stay in sync
//       db.raw(`SELECT setval('registered_user_id_seq', ?)`, [
//         users[users.length - 1].id,
//       ])
//     );
// }

// function seedArticlesTables(db, users, articles, comments = []) {
//   // use a transaction to group the queries and auto rollback on any failure
//   return db.transaction(async (trx) => {
//     await seedUsers(trx, users);
//     await trx.into('blogful_articles').insert(articles);
//     // update the auto sequence to match the forced id values
//     await trx.raw(`SELECT setval('blogful_articles_id_seq', ?)`, [
//       articles[articles.length - 1].id,
//     ]);
//     // only insert comments if there are some, also update the sequence counter
//     if (comments.length) {
//       await trx.into('blogful_comments').insert(comments);
//       await trx.raw(`SELECT setval('blogful_comments_id_seq', ?)`, [
//         comments[comments.length - 1].id,
//       ]);
//     }
//   });
// }

// function seedMaliciousArticle(db, user, article) {
//   return seedUsers(db, [user]).then(() =>
//     db.into('blogful_articles').insert([article])
//   );
// }

function makeAuthHeader(user, secret = process.env.JWT_SECRET) {
  const token = jwt.sign({ user_id: user.id }, secret, {
    subject: user.user_name,
    algorithm: 'HS256',
  });
  return `Bearer ${token}`;
}

module.exports = {
  makeUserRolesArray,
  makeRegisteredUsersArray,
  makeFlashcardsArray,
  makeDecksArray,
  //  makeArticlesArray,
  //  makeExpectedArticle,
  //  makeExpectedArticleComments,
  //  makeMaliciousArticle,
  //  makeCommentsArray,

  makeTestFixtures,
  cleanTables,
  //  seedArticlesTables,
  //  seedMaliciousArticle,
  makeAuthHeader,
  seedUsers,
  seedCardTable,
  seedDecks,
  initAllTables,
};
